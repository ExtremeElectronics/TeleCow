
*** These modified files were found in JOE when it aborted on Tue Feb 27 22:09:52 2024
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ST_
MD_
CT_
c_
p_
param_name
[100]
cl_state
cl_state
CSeq: 1 REGISTER

*** File '(Unnamed)'
From
Contact
MD5
rand
c_cnonce
c_qop
Auth
nc
c_nc
qop
nc=

*** File '(Unnamed)'
sip_client.c
sip_client.c
sip_client.h
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.h
sip_client.h
sip_client.c
sip_client.c

*** File '* Startup Log *'
Processing '/etc/joe/joerc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/joerc

*** These modified files were found in JOE when it aborted on Tue Feb 27 22:09:52 2024
*** JOE was aborted by UNIX signal 15

*** File 'sip_client.c'
/*
   Copyright 2017 Christian Taedcke <hacking@taedcke.com>

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */

#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

#include "pico/stdlib.h"
#include "pico/cyw43_arch.h"

#include "config.h"

#include "md5.h"
#include "sip_client.h"
//#include "sip_parse.h"
//#include "voip.h"
extern void send_udp(char *,int);

extern char p_realm[100];
extern char p_nonce[100];
extern char p_media[100];
extern char p_contact[100];
extern char p_to_tag[100];
extern char p_contant_type[100];
extern char p_to[100];
extern char p_from[100];
extern char p_call_id[100];
extern char p_cseq[100];
extern char p_via[100];
extern char p_qop[100];
extern char p_opaque[100];

extern enum Method p_method;
extern enum ContentType p_content_type;

int nc =0;

/*
enum SipState {
        SS_IDLE,
        SS_REGISTER_UNAUTH,
        SS_REGISTER_AUTH,
        SS_REGISTERED,
        SS_INVITE_UNAUTH,
        SS_INVITE_UNAUTH_SENT,
        SS_INVITE_AUTH,
        SS_RINGING,
        SS_CALL_START,
        SS_CALL_IN_PROGRESS,
        SS_CANCELLED,
        SS_ERROR,
};

    enum Event {
        SCE_CALL_START,
        SCE_CALL_CANCELLED,
        SCE_CALL_END,
        SCE_BUTTON_PRESS,
    };

    enum CancelReason {
        CR_UNKNOWN,
        CR_CALL_DECLINED,
        CR_TARGET_BUSY,
    };

struct SipClientEvent {


enum    Event event;
//    char button_signal = ' ';
//    uint16_t button_duration = 0;
enum    CancelReason cancel_reason;// = CR_UNKNOWN;
};
*/
/*
enum SipState m_state = SS_IDLE;    
//SocketT m_socket;    
//SocketT m_rtp_socket;    
//Md5T m_md5;    
char m_server_ip[20]; // sip servers ip    
char m_user[50]; // sip username    
char m_pwd[50];  //sippassword   
char m_my_ip[20]; // my ip address   
char m_uri[100]; // "sip:" + server_ip    
char m_to_uri[100];  //"sip:" + user + "@" + server_ip  
char m_to_contact[50]; //    
char m_to_tag[50];    
uint32_t m_sip_sequence_number;    
uint32_t m_call_id;    
//auth stuff    
char m_response[33]; //assuming length is 16    
char m_realm[50];    
char m_nonce[50];    
int m_tag;    
uint32_t m_branch;


uint32_t m_sdp_session_id;
*/

//Buffer<1024> m_tx_sdp_buffer;


//#include "sip_packet.h"

//#include "audio_client/audio_client.h"

//#include "display/display.h"

/*
#define USE_SML

#ifdef USE_SML
#include "boost/sml.hpp"
#endif

#include <cstdlib>
#include <functional>
#include <iomanip>
#include <iostream>
#include <string>
#include <vector>

#include <chrono>

class StatObject {
public:
    long freeRam;
    double processingTime;
};

std::vector<StatObject> statistics;
uint8_t istat = 0;
bool statFull = false;
StatObject statO = {};

*/


/*
static void rtp_task(void* pvParameters)
{
    LwipUdpClient* socket = (LwipUdpClient*)pvParameters;
    for (;;) {
        if (!socket->is_initialized()) {
            vTaskDelay(2000 / portTICK_RATE_MS);
            ESP_LOGI("RTP", "niezainicjowane");
            i2s_init();
            display_init();
            continue;
        }

        std::string packet = socket->receive(5000);

        if (packet.size() > 0) {
            ESP_LOGV("RTPtask", "Received %d byte", packet.size());
            if ((int)packet[0] == 128) {                
                std::chrono::high_resolution_clock::time_point begin = std::chrono::high_resolution_clock::now();
                audioRX(packet);
                audioTX(socket);
                std::chrono::high_resolution_clock::time_point end = std::chrono::high_resolution_clock::now();
                statO.freeRam = esp_get_free_heap_size();
                std::chrono::duration<double> time_span = std::chrono::duration_cast<std::chrono::duration<double>>(end - begin);
                statO.processingTime = (double)time_span.count();
                // std::cout << "duration = " << statO.processingTime << " ms, freeRAM = " << statO.freeRam << std::endl;

                if (!statFull) {
                    statistics.push_back(statO);
                    istat++;
                    statO = {};
                    if (istat == 100)
                    {
                        statFull = true;
                    }
                }
            }
        } else {
            ESP_LOGV("RTPtask", "No received data");
            i2s_pause();
            if (statFull) 
            {
                vTaskDelay(2000 / portTICK_PERIOD_MS);
                std::cout << "Statistics for 100 packets:" << std::endl;
                std::cout << " time;freeram" << std::endl;
                for (int k = 0; k < 100; k++) 
                {
                    std::cout << statistics[k].processingTime << ";" << statistics[k].freeRam << std::endl;
                }
                istat = 0;
                statistics.clear();
                statFull = false;
            }
        }
    }
}
*/
/*
SipClientInt(const std::string& user, const std::string& pwd, const std::string& server_ip, const std::string& server_port, const std::string& my_ip)
        : m_socket(server_ip, server_port, LOCAL_PORT)
        // port wyciagnac z pakietu i ip rozmowcy wstawic
        , m_rtp_socket(server_ip, "7078", LOCAL_RTP_PORT)
        , m_server_ip(server_ip)
        , m_user(user)
        , m_pwd(pwd)
        , m_my_ip(my_ip)
        , m_uri("sip:" + server_ip)
        , m_to_uri("sip:" + user + "@" + server_ip)
        , m_sip_sequence_number(std::rand() % 2147483647)
        , m_call_id(std::rand() % 2147483647)
        , m_response("")
        , m_realm("")
        , m_nonce("")
        , m_tag(std::rand() % 2147483647)
        , m_branch(std::rand() % 2147483647)
        , m_caller_display(m_user)
        , m_sdp_session_id(0)
        , m_command_event_group(xEventGroupCreate())
    {
        xTaskCreate(&rtp_task, "rtp_task", 4096, &m_rtp_socket, 4, NULL);
    }
*/
/*
    ~SipClientInt()
    {
    }
*/
/*
int strpos(char *hay, char *needle, int offset)
{
   char haystack[strlen(hay)];
   strncpy(haystack, hay+offset, strlen(hay)-offset);
   char *p = strstr(haystack, needle);
   if (p)
      return p - haystack+offset;
   return -1;
}
*/

int strpos(const char *haystack, const char *needle, int offset)
{
   const char *p = strstr(haystack+offset, needle);
   if (p)
      return p - haystack+offset;
   return -1;
}

void substr(char *source, int a, int b, char *result) 
{
        strncpy(result, source+a, b);
}


void sip_init(){
        printf("Sip Init\n");
        // dsp_ok_wifi();
        // std::cout << rtp_port;
        // bool result_rtp = m_rtp_socket.init();
  //      bool result_sip = m_socket.init();
        // return result_rtp && result_sip;

        sprintf(c_server_ip,"%s",SIP_SERVER );
//        c_socket.set_server_ip(server_ip);
//        c_rtp_socket.set_server_ip(server_ip);
        sprintf(c_uri, "sip:%s", c_server_ip);
//        sprintf(c_user, "%s", SIP_LOGIN);
        sprintf(c_user, "%s", SIP_USERNAME);
        sprintf(c_to_uri, "sip:%s@%s",c_user,c_server_ip);
        sprintf(c_realm,"%s",SIP_REALM );
        sprintf(c_pwd,"%s",SIP_PASSWORD);
        sprintf(c_my_ip,"%s",ip4addr_ntoa(netif_ip4_addr(netif_list)) );
        sprintf(c_caller_display,"%s",INIT_DISPLAY);
        c_call_id=rand() % 2147483647;
        c_tag=0;
        sprintf(c_cnonce,"%i",rand() % 2147483647);
//        sprintf(c_uri,"%s",); //ToURI ?
        //c_user = user;
        //c_pwd = password;
        //c_to_uri = "sip:" + c_user + "@" + c_server_ip);
        nc++;
        sprintf(c_nc,"%08i",nc);        
}

    /**
     * Initiate a call async
     *
     * \param[in] local_number A number that is registered locally on the server, e.g. "**610"
     * \param[in] caller_display This string is displayed on the caller's phone
     */
    void request_ring(const char* local_number, const char* caller_display)
    {
        if (cl_state == SS_REGISTERED) {
            printf("Request to call %s...\n", local_number);
            c_call_id = rand() % 2147483647;
//            c_uri = "sip:" + local_number + "@" + c_server_ip;
            sprintf(c_uri,"sip:%s@%s",local_number,c_server_ip);
//            c_to_uri = "sip:" + local_number + "@" + c_server_ip;
            sprintf(c_to_uri ,"sip:%s@%s",local_number,c_server_ip);
//            c_caller_display = caller_display;
//            xEventGroupSetBits(c_command_event_group, COMMAND_DIAL_BIT);
        }
    }

    void request_cancel()
    {
        if ((cl_state == SS_RINGING) || (cl_state == SS_CALL_IN_PROGRESS)) {
            printf( "Request to CANCEL call\n");
//            xEventGroupSetBits(c_command_event_group, COMMAND_CANCEL_BIT);
        }
    }


    //empty test function for sml transition
//    void test() const {}

    void tx()
    {
        TXTEXT
        char temp[50];
        int ssrc;
    
        switch (cl_state) {
        case SS_IDLE:
            //fall-through
        case SS_REGISTER_UNAUTH:
            //sending REGISTER without auth
            printf("TX REGISTER_UNAUTH\n");
            c_tag = rand() % 2147483647;
            c_branch = rand() % 2147483647;
            send_sip_register();
            c_tag = rand() % 2147483647;
            c_branch = rand() % 2147483647;
            break;
        case SS_REGISTER_AUTH:
            printf("TX REGISTER_AUTH\n");
            //sending REGISTER with auth
            sprintf(temp,"sip:%s",c_my_ip);
            //compute_auth_response("REGISTER", "sip:" + c_server_ip);
            compute_auth_response("REGISTER", temp);
            
            send_sip_register();
            break;
        case SS_REGISTERED:
            printf("TX REGISTERED\n");
            //wait for request
            break;
        case SS_INVITE_UNAUTH:
            printf("TX INVIATE_UNAUTH\n");
            //sending INVITE without auth
            //c_tag = rand() % 2147483647;
            c_sdp_session_id = rand();
            send_sip_invite();
            break;
        case SS_INVITE_UNAUTH_SENT:
            printf("TX INVITE_UNAUTH_SENT\n");
            break;
        case SS_INVITE_AUTH:
            printf("TX INVITE_AUTH\n");
            //sending INVITE with auth
            c_branch = rand() % 2147483647;
            compute_auth_response("INVITE", c_uri);
            send_sip_invite();
            break;
        case SS_RINGING:
            printf("TX RINGING\n");
            // RTP ssrc generation
            ssrc = rand() % 2147483647;
            //if (xEventGroupWaitBits(c_command_event_group, COMMAND_CANCEL_BIT, true, true, 0)) {
                // ESP_LOGD(TAG, "Sending cancel request");
                send_sip_cancel();
            //}
            break;
        case SS_CALL_START:
            printf("TX CALL_START\n");
            send_sip_ack();
            break;
        case SS_CALL_IN_PROGRESS:
            printf("TX CALL_IN_PROGRESS\n");
            //if (xEventGroupWaitBits(c_command_event_group, COMMAND_CANCEL_BIT, true, true, 0)) {
//                printf( "Sending bye request");
//                send_sip_bye();
            //}
            break;
        case SS_CANCELLED:
            printf("TX CANCLLED\n");
            send_sip_ack();
            c_tag = rand() % 2147483647;
            c_branch = rand() % 2147483647;
            break;
        case SS_ERROR:
            printf("TX ERROR\n");
            break;
        }
        CLTEXT
    }

    void rx()
    {
        RXTEXT
        printf("RX - State:%i\n",cl_state);
    
        if (cl_state == SS_REGISTERED) {
           printf("RX REGISTERED\n");
   //         if (xEventGroupWaitBits(c_command_event_group, COMMAND_DIAL_BIT, true, true, 0)) {
                cl_state = SS_INVITE_UNAUTH;
                log_state_transition(SS_REGISTERED, cl_state);
     //       }
            //return;
        } else if (cl_state == SS_ERROR) {
            printf("RX SS_ERROR\n");
            //vTaskDelay(2000 / portTICK_RATE_MS);
            sleep_ms(2000);
            c_sip_sequence_number++;
            cl_state = SS_IDLE;
            log_state_transition(SS_ERROR, cl_state);
            return;
        } else if (cl_state == SS_INVITE_UNAUTH) {
            printf("RX INVITE_UNAUTH\n");
            cl_state = SS_INVITE_UNAUTH_SENT;
            log_state_transition(SS_INVITE_UNAUTH, cl_state);
            return;
        } else if (cl_state == SS_CALL_START) {
            printf("RX CALL_START\n");
            cl_state = SS_CALL_IN_PROGRESS;
            log_state_transition(SS_CALL_START, cl_state);
            return;
        }

        //The timeout is a workaround to be able to end a CANCEL request during ring
       // char recv_string = c_socket.receive(SOCKET_RX_TIMEOUT_MSEC);

        //if (recv_string.empty()) {
          //  return;
        //}


        //TO DO PARSE RESPONCE

//        packet(recv_string.c_str(), recv_string.size());
        if (!parse()) {
            printf("Parsing the packet failed");
            return;
        }

        enum Status reply = p_status;   //get_status();
        printf( "Parsing the packet ok, reply code=%d", p_status); // get_status());

        if (reply == ST_SERVER_ERROR_500) {
            printf("RX SERVER_ERROR_500\n");
            log_state_transition(cl_state, SS_ERROR);
            cl_state = SS_ERROR;
            return;
        } else if ((reply == ST_UNAUTHORIZED_401) || (reply == ST_PROXY_AUTH_REQ_407)) {
              printf("RX UNAUTHORIZED_401 PROXY_AUTH_REQ_407\n");
//            c_realm = get_realm();
//            strncat(c_realm,p_realm,PARSE_MAX);
//            strncat(c_realm,SIP_REALM,PARSE_MAX);
            sprintf(c_realm,"%s",p_realm );
//            c_nonce = get_nonce();
            strncat(c_nonce,p_nonce,PARSE_MAX);
        } else if ((reply == ST_UNKNOWN) && ((p_method == MD_NOTIFY) || (p_method == MD_BYE) || (p_method == MD_INFO) || (p_method == MD_INVITE))) {
             printf("RX MD_Various :)\n");
//        } else if ((reply == ST_UNKNOWN) && ((get_method() == MD_NOTIFY) || (get_method() == MD_BYE) || (get_method() == MD_INFO) || (get_method() == MD_INVITE))) {
            send_sip_ok();
//            if ((get_method() == MD_INVITE)) {
            if ((p_method == MD_INVITE)) {
                printf("RX MD_INVITE :)\n");
                char media[100];
                strncat(media,p_media,PARSE_MAX);
//                int m1 = media.find(' ');
                int m1=strpos(" ",media,0); 
//                int m2 = media.find(' ', m1 + 1);
                int m2=strpos(" ",media,m1+1);
//                rtp_port = media.substr(m1 + 1, m2 - m1 - 1);
//                rtp_port = media.substr(m1 + 1, m2 - m1 - 1);
                 substr(media,m1 + 1, m2 - m1 - 1,rtp_port);                
                // inicjalizacja rtp
                //std::cout << rtp_port;
                
                //RTP TO DO
//                c_rtp_socket.set_server_ip(get_cip());
//                c_rtp_socket.set_server_port(rtp_port);
//                c_rtp_socket.init();
            }
        }

        if (p_contact[0]) {
//        if (!get_contact().empty()) {
//            c_to_contact = get_contact();
            strncat(c_to_contact,p_contact,PARSE_MAX);
        }

//        if (!get_to_tag().empty()) {
          if (p_to_tag[0]) {
//            c_to_tag = get_to_tag();
            strncat(c_to_tag,p_to_tag,PARSE_MAX);

        }

        enum SipState old_state = cl_state;
        switch (cl_state) {
        case SS_IDLE:
            //fall-trough
        case SS_REGISTER_UNAUTH:
            printf("RX SS_REGISTER_UNAUTH \n");
            cl_state = SS_REGISTER_AUTH;
            c_sip_sequence_number++;
            break;
        case SS_REGISTER_AUTH:
            printf("RX SS_REGISTER_AUTH \n");
            if (reply == ST_OK_200) {
                printf("RX ST_OK_200 )\n");
                c_sip_sequence_number++;
//                c_nonce = "";
                sprintf(c_nonce,"");
//                c_realm = "";
                sprintf(c_realm,"");
//                c_response = "";
                sprintf(c_response,"");
                printf( "REGISTER - OK :)");
//                c_uri = "sip:**613@" + c_server_ip;
                sprintf(c_uri,"sip:**613@%s",c_server_ip);
//                c_to_uri = "sip:**613@" + c_server_ip;
                sprintf(c_to_uri,"sip:**613@%s",c_server_ip);
                cl_state = SS_REGISTERED;
            } else {
                cl_state = SS_ERROR;
                printf("RX SS_ERROR \n");
            }
            break;
        case SS_REGISTERED:
            printf("RX SS_REGISTERED \n");
            if (p_method == MD_INVITE  ) {
                //received an invite, answered it already with ok, so new call is established, because someone called us
                cl_state = SS_CALL_START;
//                if (c_event_handler) {
//                    c_event_handler(SipClientEvent{ SipClientEvent::Event::CALL_START });
//                }
            }
            break;
        case SS_INVITE_UNAUTH_SENT:
        case SS_INVITE_UNAUTH:
            printf("RX SS_INVITE_UNAUTH \n");
            if ((reply == ST_UNAUTHORIZED_401) || (reply == ST_PROXY_AUTH_REQ_407)) {
                printf("RX ST_UNAUTHORIZED_401 / ST_PROXY_AUTH_REQ_407 \n");
                cl_state = SS_INVITE_AUTH;
                send_sip_ack();
                c_sip_sequence_number++;
            } else if ((reply == ST_OK_200) || (reply == ST_SESSION_PROGRESS_183)) {
                printf("ST_OK_200 / ST_SESSION_PROGRESS_183\n");
                cl_state = SS_RINGING;
//                c_nonce = "";
                sprintf(c_nonce,"");
//                c_realm = "";
                sprintf(c_realm,"");
//                c_response = "";
                sprintf(c_response,"");
                printf(TAG, "Start RINGing...");
            } else if (reply != ST_TRYING_100) {
                cl_state = SS_ERROR;
            }
            break;
        case SS_INVITE_AUTH:
            if ((reply == ST_UNAUTHORIZED_401) || (reply == ST_PROXY_AUTH_REQ_407)) {
                printf("ST_UNAUTHORIZED_401 / ST_PROXY_AUTH_REQ_407\n");
                cl_state = SS_ERROR;
            } else if ((reply == ST_OK_200) || (reply == ST_SESSION_PROGRESS_183) || (reply == ST_TRYING_100)) {
                printf("ST_OK_200 / ST_SESSION_PROGRESS_183 / reply == ST_TRYING_100\n");
                //trying is not yet ringing, but change state to not send invite again
                cl_state = SS_RINGING;
//                c_nonce = "";
                 sprintf(c_nonce,"");
//                c_realm = "";
                sprintf(c_realm,"");
//                c_response = "";
                sprintf(c_response,"");
                printf( "Start RINGing...");
            } else {
                cl_state = SS_ERROR;
            }
            break;
        case SS_RINGING:
            printf("SS_RINGING\n");
            if (reply == ST_SESSION_PROGRESS_183) {
                printf("ST_SESSION_PROGRESS_183\n");
                //TODO parse session progress reply and send appropriate answer
                //cl_state = SS_ERROR;
            } else if (reply == ST_OK_200) {
                printf("ST_OK_200\n");
                //other side picked up, send an ack
                cl_state = SS_CALL_START;
//                if (c_event_handler) {
//                    c_event_handler(SipClientEvent{ SipClientEvent::Event::CALL_START });
//                }
            } else if (reply == ST_REQUEST_CANCELLED_487) {
                cl_state = SS_CANCELLED;
                 printf("SS_CANCELLED\n");
//                if (c_event_handler) {
//                    c_event_handler(SipClientEvent{ SipClientEvent::Event::CALL_CANCELLED });
//                }
            } else if (reply == ST_PROXY_AUTH_REQ_407) {
                printf("ST_PROXY_AUTH_REQ_407\n");
                send_sip_ack();
                c_sip_sequence_number++;
                cl_state = SS_INVITE_AUTH;
                printf( "Go back to send invite with auth...");
            } else if ((reply == ST_DECLINE_603) || (reply == ST_BUSY_HERE_486)) {
                printf("ST_DECLINE_603 ST_BUSY_HERE_486\n");
                send_sip_ack();
                c_sip_sequence_number++;
                c_branch = rand() % 2147483647;
                cl_state = SS_REGISTERED;
                enum CancelReason cancel_reason = CR_CALL_DECLINED;
                if (reply == ST_BUSY_HERE_486) {
                    cancel_reason = CR_TARGET_BUSY;
                }
//                if (c_event_handler) {
//                    c_event_handler(SipClientEvent{ SipClientEvent::Event::CALL_CANCELLED, ' ', 0, cancel_reason });
//                }
            }
            break;
        case SS_CALL_START:
            //should not reach this point
            printf("Call START-ERROR\n");
            break;
        case SS_CALL_IN_PROGRESS:
            printf("SS_CALL_IN_PROGRESS\n");
            if (p_method == MD_BYE) {
                c_sip_sequence_number++;
                cl_state = SS_REGISTERED;
//                if (c_event_handler) {
//                    c_event_handler(SipClientEvent{ SipClientEvent::Event::CALL_END });
//                }
            } else if ((p_method == MD_INFO) && (p_content_type == CT_APPLICATION_DTMF_RELAY)) {
                printf("MD_INFO / CT_APPLICATION_DTMF_RELAY\n");
//                if (c_event_handler) {
//                    c_event_handler(SipClientEvent{ SipClientEvent::Event::BUTTON_PRESS, packet.get_dtmf_signal(), packet.get_dtmf_duration() });
//                }
            }
            break;
        case SS_CANCELLED:
            printf("SS_CANCELLED\n");
            if (reply == ST_OK_200) {
                c_sip_sequence_number++;
                cl_state = SS_REGISTERED;
            }
            break;
        case SS_ERROR:
            printf("SS_ERROR\n");
            c_sip_sequence_number++;
            cl_state = SS_IDLE;
            break;
        }

        if (old_state != cl_state) {
            log_state_transition(old_state, cl_state);
        }
        CLTEXT
    }

    void send_sip_register()
    {
        printf("Send SIP Register\n");
        //TxBufferT& tx_buffer = c_socket.get_new_tx_buf();
        char buffer[1024];
        //char uri = "sip:" + c_server_ip;
        char uri[100];
//        sprintf(uri,"sip:%s:%s", c_server_ip,LOCAL_PORT);
        sprintf(uri,"sip:%s:%i", c_my_ip,LOCAL_PORT);
        char temp[100];
        sprintf(temp,"sip:%s@%s",c_user,c_server_ip);
//        send_sip_header("REGISTER", uri, "sip:" + c_user + "@" + c_server_ip, tx_buffer);
//        printf("Before header\n");
//        sleep_ms(500);
        sip_header("REGISTER", uri, temp, buffer);
//        printf("DEBUG: Contact: \"%s\" <sip:%s@%s:%i;transport=%s\r\n",buffer,c_user,c_user,c_my_ip,LOCAL_PORT,TRANSPORT_LOWER );
//        tx_buffer << "Contact: \"" << c_user << "\" <sip:" << c_user << "@" << c_my_ip << ":" << LOCAL_PORT << ";transport=" << TRANSPORT_LOWER << ">\r\n";
//        sprintf(buffer,"%sContact: \"%s\" <sip:%s@%i:%i;transport=%s\r\n",buffer,c_user,c_user,c_my_ip,LOCAL_PORT,TRANSPORT_LOWER );
//        sprintf(buffer,"%sContact: <sip:%s@%s:%i>;transport=%s\r\n",buffer,c_user,c_my_ip,LOCAL_PORT,TRANSPORT_LOWER );
//        sprintf(buffer,"%sContact: <sip:%s@%s:%i;ob>\r\n",buffer,c_user,c_my_ip,LOCAL_PORT );
        sprintf(buffer,"%sContact: <sip:%s@%s:%i;transport=%s>\r\n",buffer,SIP_LOGIN,c_my_ip,LOCAL_PORT,TRANSPORT_LOWER  );

        if (c_response[0]) {
//            tx_buffer << "Authorization: Digest username=\"" << c_user << "\", realm=\"" << c_realm << "\", nonce=\"" << c_nonce << "\", uri=\"" << uri << "\", algorithm=MD5, response=\"" << c_response << "\"\r\n";
//            sprintf(buffer,"%sAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", algorithm=MD5, response=\"%s\"\r\n",buffer, c_user ,c_realm ,c_nonce,uri ,c_response );
            sprintf(buffer,"%sAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", algorithm=MD5, response=\"%s\", qop=%s, opaque=\"%s\", cnonce=\"%s\", nc=%s\r\n",buffer, c_user ,c_realm ,c_nonce,uri ,c_response,p_qop,p_opaque,c_cnonce,c_nc );
            
        }
//        tx_buffer << "Allow: INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, NOTIFY, MESSAGE, SUBSCRIBE, INFO\r\n";
        sprintf(buffer,"%sAllow: INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, NOTIFY, MESSAGE, SUBSCRIBE, INFO\r\n",buffer);
//        tx_buffer << "Expires: 3600\r\n";
        sprintf(buffer,"%sExpires: 600\r\n",buffer);
//        tx_buffer << "Content-Length: 0\r\n";
        sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
//        tx_buffer << "\r\n";
        sprintf(buffer,"%s\r\n",buffer);

//        c_socket.send_buffered_data();

        printf("\n\nSIP Register - Send UDP \n%s\nLEN %i\n",buffer,strlen(buffer));
//        sprintf(buffer,"The Quick Brown Fox Jumps Over the Lazy Dog\r\n");
        send_udp(buffer,strlen(buffer));
        sleep_ms(100);
    }

    void send_sip_invite()
    {
        char buffer[1024];
        char sdp_buffer[1024];
//        TxBufferT& tx_buffer = c_socket.get_new_tx_buf();

        sip_header("INVITE", c_uri, c_to_uri, buffer);

//        tx_buffer << "Contact: \"" << c_user << "\" <sip:" << c_user << "@" << c_my_ip << ":" << LOCAL_PORT << ";transport=" << TRANSPORT_LOWER << ">\r\n";
        sprintf(buffer,"%sContact: \"%s\" <sip:%s@%s:%i;transport=%s\r\n",buffer,c_user,c_user,c_my_ip,LOCAL_PORT,TRANSPORT_LOWER );

        if (c_response[0]) {
//            tx_buffer << "Authorization: Digest username=\"" << c_user << "\", realm=\"" << c_realm << "\", nonce=\"" << c_nonce << "\", uri=\"" << c_uri << "\", response=\"" << c_response << "\"\r\n";
//            sprintf(buffer,"%sAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", algorithm=MD5, response=\"%s\"\r\n",buffer, c_user ,c_realm ,c_nonce,c_uri ,c_response );
            sprintf(buffer,"%sAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", algorithm=MD5, response=\"%s\", qop=%s, nc=%s, opaque=\"%s\"\r\n",buffer, c_user ,c_realm ,c_nonce,c_uri ,c_response,p_qop,c_nc,p_opaque );
        }
//        tx_buffer << "Content-Type: application/sdp\r\n";
        sprintf(buffer,"%sContent-Type: application/sdp\r\n",buffer);
        
//        tx_buffer << "Allow: INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, NOTIFY, MESSAGE, SUBSCRIBE, INFO\r\n";
        sprintf(buffer,"%sAllow: INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, NOTIFY, MESSAGE, SUBSCRIBE, INFO\r\n",buffer);
        
//        c_tx_sdp_buffer.clear();
/*        
        c_tx_sdp_buffer << "v=0\r\n"
                        << "o=" << c_user << " " << c_sdp_session_id << " " << c_sdp_session_id << " IN IP4 " << c_my_ip << "\r\n"
                        << "s=sip-client/0.0.1\r\n"
                        << "c=IN IP4 " << c_my_ip << "\r\n"
                        << "t=0 0\r\n"
                        // << "m=audio " << LOCAL_RTP_PORT << " RTP/AVP 0 8 101\r\n"
                        << "m=audio " << LOCAL_RTP_PORT << " RTP/AVP 8 101\r\n"
                        << "a=sendrecv\r\n"
                        //<< "a=recvonly\r\n"
                        << "a=rtpmap:101 telephone-event/8000\r\n"
                        << "a=fmtp:101 0-15\r\n"
                        << "a=ptime:20\r\n";
*/
        sprintf(sdp_buffer,"v=0\r\no=%s %s %s IN IP4 %s\r\n",c_user, c_sdp_session_id, c_sdp_session_id ,c_my_ip);
        sprintf(sdp_buffer,"%ss=sip-client/0.0.1\r\nc=IN IP4 %s\r\nt=0 0\r\nm=audio %s  RTP/AVP 8 101\r\n",sdp_buffer,c_my_ip,LOCAL_RTP_PORT);
        sprintf(sdp_buffer,"%sa=sendrecv\r\na=rtpmap:101 telephone-event/8000\r\na=fmtp:101 0-15\r\na=ptime:20\r\n",sdp_buffer);
                         
//        tx_buffer << "Content-Length: " << c_tx_sdp_buffer.size() << "\r\n";
        sprintf(buffer,"%sContent-Length: 0\r\n",buffer,strlen(sdp_buffer));
//        tx_buffer << "\r\n";
        sprintf(buffer,"%s\r\n",buffer);
//        tx_buffer << c_tx_sdp_buffer.data();
        sprintf(buffer,"%s",sdp_buffer);

//        c_socket.send_buffered_data();
        printf("\n\nSIP INVITE - Send UDP %s\n",buffer);
        send_udp(buffer,strlen(buffer));
        sleep_ms(100);
    }

    /**
     * CANCEL a pending INVITE
     *
     * To match the INVITE, the following parameter must not be changed:
     * * CSeq
     * * From tag value
     */
    void send_sip_cancel()
    {
//        TxBufferT& tx_buffer = c_socket.get_new_tx_buf();
        char buffer[1024];
        sip_header("CANCEL", c_uri, c_to_uri, buffer);

        if (c_response[0]) {
//            tx_buffer << "Contact: \"" << c_user << "\" <sip:" << c_user << "@" << c_my_ip << ":" << LOCAL_PORT << ";transport=" << TRANSPORT_LOWER << ">\r\n";
            sprintf(buffer,"%sContact: \"%s\" <sip:%s@%s:%i;transport=%s\r\n",buffer,c_user,c_user ,c_my_ip,LOCAL_PORT,TRANSPORT_LOWER );
//            tx_buffer << "%sContent-Type: application/sdp\r\n";
            sprintf(buffer,"%sContent-Type: application/sdp\r\n",buffer);
//            tx_buffer << "Authorization: Digest username=\"" << c_user << "\", realm=\"" << c_realm << "\", nonce=\"" << c_nonce << "\", uri=\"" << c_uri << "\", response=\"" << c_response << "\"\r\n";
            sprintf(buffer,"%sAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s,\"\r\n",buffer,c_user,c_realm ,c_nonce,c_uri,c_response );
        }
//        tx_buffer << "Content-Length: 0\r\n";
        sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
//        tx_buffer << "\r\n";
        sprintf(buffer,"%s\r\n",buffer);

  //      c_socket.send_buffered_data();
        send_udp(buffer,strlen(buffer));
    }

    /**
     * BYE a pending CALL
     * ~ todo sikor
     * To match the CALL, the following parameter must not be changed:
     * * CSeq
     * * From tag value
     */
    void send_sip_bye()
    {
        //TxBufferT& tx_buffer = c_socket.get_new_tx_buf();
        char buffer[1024];
        c_sip_sequence_number = 104;

        sip_header("BYE", c_uri, c_to_uri, buffer);

        if (c_response[0]) {
//            tx_buffer << "Contact: \"" << c_user << "\" <sip:" << c_user << "@" << c_my_ip << ":" << LOCAL_PORT << ";transport=" << TRANSPORT_LOWER << ">\r\n";
            sprintf(buffer,"%sContact: \"%s\" <sip:%s@%s:%i;transport=%s\r\n",buffer,c_user,c_user ,c_my_ip,LOCAL_PORT,TRANSPORT_LOWER );
//            tx_buffer << "Content-Type: application/sdp\r\n";
            sprintf(buffer,"%sContent-Type: application/sdp\r\n",buffer);
//            tx_buffer << "Max-Forwards: 70\r\n";
            sprintf(buffer,"%sMax-Forwards: 70\r\n",buffer);
//            tx_buffer << "Authorization: Digest username=\"" << c_user << "\", realm=\"" << c_realm << "\", nonce=\"" << c_nonce << "\", uri=\"" << c_uri << "\", response=\"" << c_response << "\"\r\n";
            sprintf(buffer,"%sAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s,\"\r\n",buffer,c_user,c_realm ,c_nonce,c_uri,c_response );
        }
//        tx_buffer << "Content-Length: 0\r\n";
        sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
//        tx_buffer << "\r\n";
        sprintf(buffer,"%s\r\n",buffer);
//        c_socket.send_buffered_data();
       send_udp(buffer,strlen(buffer));
    }

    void send_sip_ack()
    {
//        TxBufferT& tx_buffer = c_socket.get_new_tx_buf();
        char buffer[1024];      
        
        if (cl_state == SS_CALL_START) {
            sip_header("ACK", c_to_contact, c_to_uri, buffer);
            //std::string c_sdp_session_o;
            //std::string c_sdp_session_s;
            //std::string c_sdp_session_c;
            //c_tx_sdp_buffer.clear();
            //TODO: populate sdp body
            //c_tx_sdp_buffer << "v=0\r\n"
            //	              << c_sdp_session_o << "\r\n"
            //	      << c_sdp_session_s << "\r\n"
            //	      << c_sdp_session_c << "\r\n"
            //	      << "t=0 0\r\n";
            //TODO: copy each m line and select appropriate a line
            //tx_buffer << "Content-Type: application/sdp\r\n";
            sprintf(buffer,"%sContent-Type: application/sdp\r\n",buffer);
            //tx_buffer << "Content-Length: " << c_tx_sdp_buffer.size() << "\r\n";
            sprintf(buffer,"%sContent-Length: %i\r\n",strlen(buffer));
            //tx_buffer << "Allow-Events: telephone-event\r\n";
            sprintf(buffer,"%sAllow-Events: telephone-event\r\n",buffer);
//            tx_buffer << "Content-Length: 0\r\n";
            sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
//            tx_buffer << "\r\n";
            sprintf(buffer,"%s\r\n",buffer);
            //tx_buffer << c_tx_sdp_buffer.data();
        } else {
            sip_header("ACK", c_uri, c_to_uri, buffer);
            //tx_buffer << "Content-Length: 0\r\n";
            sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
            //tx_buffer << "\r\n";
            sprintf(buffer,"%s\r\n",buffer);
        }
        //c_socket.send_buffered_data();
        send_udp(buffer,strlen(buffer));
    }

    void send_sip_ok()
    {
        //TxBufferT& tx_buffer = c_socket.get_new_tx_buf();
        char buffer[1024];
        sip_reply_header("200 OK"  ,  buffer);
//        tx_buffer << "Content-Length: 0\r\n";
        sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
//        tx_buffer << "\r\n";
        sprintf(buffer,"%s\r\n",buffer);

//        c_socket.send_buffered_data();
        send_udp(buffer,strlen(buffer));
        
    }

    void sip_header(const char * command, const char * uri, const char * to_uri, char * buffer)
    {
        printf("sip_header CMD:%s\n",command);
//      stream << command << " " << uri << " SIP/2.0\r\n";        
        sprintf(buffer,"%s %s SIP/2.0\r\n",command,uri);  
//        printf("DEBUG:%s %s SIP/2.0\r\n",command,uri);

//      stream << "CSeq: " << c_sip_sequence_number << " " << command << "\r\n";
        sprintf(buffer,"%sCSeq: %i %s \r\n",buffer,c_sip_sequence_number,command );
//        printf("DEBUG:%sCSeq: %i %s \n\n",buffer,c_sip_sequence_number,command );
//      stream << "Call-ID: " << c_call_id << "@" << c_my_ip << "\r\n";        
        sprintf(buffer,"%sCall-ID:%i@%s\r\n",buffer,c_call_id,c_my_ip);
//      stream << "Max-Forwards: 70\r\n";        
        sprintf(buffer,"%sMax-Forwards: 70\r\n",buffer);
//      stream << "User-Agent: sip-client/0.0.1\r\n";
        sprintf(buffer,"%sUser-Agent: sip-client/0.0.1\r\n",buffer);
        
//        printf("DEBUG: %s\n",buffer);
//        sleep_ms(100);      
        
        if (strcmp(command,"REGISTER")) {
            printf("Header INVITE\n");
//            stream << "From: <sip:" << c_user << "@" << c_server_ip << ">;tag=" << c_tag << "\r\n";
            sprintf(buffer,"%sFrom: <sip:%s@%s>;tag=%i\r\n)",buffer,c_user,c_server_ip,c_tag);
//            sprintf(buffer,"%sFrom: <sip:%s@%s>;tag=%i\r\n)",buffer,c_user,c_my_ip,c_tag);
//            sprintf(buffer,"%sFrom: <sip:%s@%s>;tag=%i\r\n)",buffer,c_user,c_server_ip,c_tag);
        } else if (strcmp(command,"INVITE")) {
            printf("Header REGISTER\n");
//            stream << "From: \"" << c_caller_display << "\" <sip:" << c_user << "@" << c_server_ip << ">;tag=" << c_tag << "\r\n";
/*            printf("C_disp %s\n",c_caller_display);
            sleep_ms(100);
            printf("c_user %s\n",c_user);
            sleep_ms(100);
            printf("c_server_ip%s\n",c_server_ip);
            sleep_ms(100);
            printf("c_tag%s\n",c_tag);
            sleep_ms(100);
*/
            sprintf(buffer,"%sFrom: \"%s\" <sip:%s@%s>;tag=%i\r\n",buffer,c_caller_display,SIP_LOGIN,c_my_ip,c_tag);
//            printf("From: %s %s %s %i\r\n",c_caller_display,c_user,c_server_ip,c_tag);            
//            sleep_ms(100);
        } else {
            printf("Header not REGISTER or INVITE\n");
//            stream << "From: \"" << c_user << "\" <sip:" << c_user << "@" << c_server_ip << ">;tag=" << c_tag << "\r\n";
            sprintf(buffer,"%sFrom: \"%s\" <sip:%s@%s>;tag=%i\r\n",buffer,c_user,c_user,c_server_ip,c_tag);
        }
        //stream << "Via: SIP/2.0/" << TRANSPORT_UPPER << " " << c_my_ip << ":" << LOCAL_PORT << ";branch=z9hG4bK-" << c_branch << ";rport\r\n";
        sprintf(buffer,"%sVia: SIP/2.0/%s %s:%i;branch=z9hG4bK-%i;rport\r\n",buffer,TRANSPORT_UPPER,c_my_ip ,LOCAL_PORT,c_branch);
//        sprintf(buffer,"%sVia: SIP/2.0/%s %s:%i;branch=z9hG4bK-%i\r\n",buffer,TRANSPORT_UPPER,c_my_ip ,LOCAL_PORT,c_branch);
        /*
        sleep_ms(100);
            printf("TRANSPORT_UPPER %s\n",TRANSPORT_UPPER);
        sleep_ms(100);
            printf("c_my_ip %s\n",c_my_ip );
        sleep_ms(100);
            printf("LOCAL_PORT %i\n",LOCAL_PORT);
            sleep_ms(100);
            printf("c_branch %i\n",c_branch);        
        */    
        if ((strcmp(command,"ACK")) && (c_to_tag[0])) {
            printf("notACK\n");
//            stream << "To: <" << to_uri << ">;tag=" << c_to_tag << "\r\n";
            //sprintf(buffer,"%sTo: <%s>;tag=%s\r\n",buffer,to_uri,c_to_tag);   
            sprintf(buffer,"%sTo: <sip:%s@%s>;tag=%s\r\n",buffer,SIP_LOGIN,c_my_ip,c_to_tag);   
            
        } else {
            printf("ACK\n");
//            stream << "To: <" << to_uri << ">\r\n";
            //sprintf(buffer,"%sTo: <%s>\r\n",buffer,to_uri);
            sprintf(buffer,"%sTo: <sip:%s@%s>\r\n",buffer,SIP_LOGIN,c_my_ip);
        }
//        printf("DEBUG sip_header output: %s",buffer);
//        sleep_ms(100);
    }

    void sip_reply_header(char * code,char * buffer)
    {
        printf("Sip Reply header\n");
//        stream << "SIP/2.0 " << code << "\r\n";
        sprintf(buffer,"SIP/2.0 %s \r\n",code);
//        stream << "To: " << packet.get_to() << "\r\n";
        //sprintf(buffer,"%sTo: %s\r\n",buffer,p_to);
        sprintf(buffer,"%sTo: %s\r\n",buffer,p_to);
        
        //stream << "From: " << packet.get_from() << "\r\n";
        sprintf(buffer,"%sFrom: %s\r\n",buffer,p_from);
        //stream << "Via: " << packet.get_via() << "\r\n";
        sprintf(buffer,"%sVia: %s\n\r",buffer,p_via);
//        stream << "CSeq: " << packet.get_cseq() << "\r\n";
        sprintf(buffer,"%sCSeq: %s\n\r",buffer,p_cseq);
//        stream << "Call-ID: " << packet.get_call_id() << "\r\n";
        sprintf(buffer,"%sCall-ID: %s\n\r",buffer,p_call_id);
        //stream << "Max-Forwards: 70\r\n";
        sprintf(buffer,"Max-Forwards: 70\r\n",buffer);      
        
        
    }
    

    bool read_param_client(const char * line, const char * parac_name, char * output)
    {
        char param[100];
        sprintf(param,"%s=\"",parac_name);
//        char param(parac_name + "=\"");
//        size_t pos = line.find(param);
        int pos = strpos(line,param,0);
        if (pos == -1) {
            return false;
        }
//        pos += param.size();
        pos += strlen(param);
//        size_t pos_end = line.find("\"", pos);
        int pos_end = strpos(line,param,pos);
        if (pos_end == -1) {
            return false;
        }
        //output = line.substr(pos, pos_end - pos);
        substr(line,pos,pos_end,output);
        return true;
    }

    void compute_auth_response(const char * method, const char * uri)
    {
        char ha1_text[50];
        char ha2_text[50];
        unsigned char hash[16];
        char ccnonce[50];
//        c_response = "";
        sprintf(c_response,"");
        char data[1024];
        MD5_CTX mdContext;
        
        //HA1 from user relm password
        
        //char data = c_user + ":" + c_realm + ":" + c_pwd;
        sprintf(data,"%s:%s:%s",c_user,c_realm,c_pwd);
        
        MD5Init (&mdContext);
        MD5Update (&mdContext,data,strlen(data));
        MD5Final (&mdContext);

        //c_md5.start();
        //c_md5.update(data);
        //c_md5.finish(hash);
        to_hex(ha1_text, mdContext.digest, 16);
        printf( "Calculating md5 for : %s\n", data);
        printf("Hex ha1 is %s\n", ha1_text);

        
        //HA2 Method uri
        //data = method + ":" + uri;
        sprintf(data,"%s:%s",method,uri);
        
        MD5Init (&mdContext);
        MD5Update (&mdContext,data,strlen(data));
        MD5Final (&mdContext);

//        c_md5.start();
//        c_md5.update(data);
//        c_md5.finish(hash);
        to_hex(ha2_text, mdContext.digest, 16);
        printf( "Calculating md5 for : %s\n", data);
        printf( "Hex ha2 is %s\n", ha2_text);

//        data = ha1_text + ":" + c_nonce + ":" + ha2_text;

        if(p_qop[0]==0){
           //without QOP
           //responce HA1 nonce HA2 
        
           sprintf(data,"%s:%s:%s",ha1_text,c_nonce, ha2_text);
        }else{
           //with QOP
           //responce HA1 nonce cnonce qop HA2
           printf("QOP AUTH\n");
           sprintf(data,"%s:%s:%s:%s:%s",ha1_text,c_nonce,c_nc,c_cnonce,p_qop,ha2_text);

        } 
        
        
//        c_md5.start();
//        c_md5.update(data);
//        c_md5.finish(hash);
        MD5Init (&mdContext);
        MD5Update (&mdContext,data,strlen(data));
        MD5Final (&mdContext);

        to_hex(c_response,  mdContext.digest, 16);
        printf("Calculating md5 for : %s\n", data);
        printf("Hex response is %s\n", c_response);
    }

    void to_hex(char * dest, const unsigned char* data, int len)
    {
        static const char hexits[17] = "0123456789abcdef";

//        dest = "";
//        dest.reserve(len * 2 + 1);
//        char dest[len * 2 + 1];
        int c=0;
        for (int i = 0; i < len; i++) {
            dest[c]=hexits[data[i] >> 4];
            c++;
            dest[c]=hexits[data[i] & 0x0F];
            c++;
        }
    }

    void log_state_transition(enum SipState old_state, enum SipState new_state)
    {
  //      ESP_LOGI(TAG, "New state %d -> %d", (int)old_state, (int)new_state);

        switch (new_state) {
        case SS_IDLE:
//            dsp_ok_wifi();
//            vTaskDelay(1500 / portTICK_PERIOD_MS);
//            dsp_wait_sip();
            break;
        case SS_REGISTERED:
//            dsp_ok_sip();
            break;
        case SS_REGISTER_UNAUTH:
//            dsp_wait_sip();
            break;
        case SS_CALL_IN_PROGRESS:
//            dsp_call();
            break;
        default:
            break;
        }
    }

//    std::function<void(const SipClientEvent&)> c_event_handler;

    /* FreeRTOS event group to signal commands from other tasks 
    EventGroupHandle_t c_command_event_group;
    static constexpr uint8_t COMMAND_DIAL_BIT = BIT0;
    static constexpr uint8_t COMMAND_CANCEL_BIT = BIT1;

    static constexpr const uint16_t LOCAL_PORT = 5060;
    static constexpr const char* TRANSPORT_LOWER = "udp";
    static constexpr const char* TRANSPORT_UPPER = "UDP";

    static constexpr uint32_t SOCKET_RX_TIMEOUT_MSEC = 200;
    static constexpr uint16_t LOCAL_RTP_PORT = 7078;
    std::string rtp_port = "1234";
    static constexpr const char* TAG = "SipClient";
};
*/

/*
template <class SipClientT>
struct sip_states {
    auto operator()() const noexcept
    {
        using namespace sml;

        const auto idle = state<class idle>;

        const auto action = [](SipClientT& sip, const auto& event) { /// event is deduced, order is not important
            (void)event;
            sip.test();
        };

        return make_transition_table(
            *idle + event<ev_start> = "s1"_s, "s1"_s + sml::on_entry<_> / [] { ESP_LOGV("SIP SM", "s1 on entry"); }, "s1"_s + sml::on_exit<_> / [] { ESP_LOGV("SIP SM", "s1 on exit"); }, "s1"_s + event<ev_2> / action = state<class s2>, state<class s2> + event<ev_3> = X);
    }
};
*/

/*
    bool init()
    {
        return c_sip.init();
    }

    bool is_initialized() const
    {
        return c_sip.is_initialized();
    }

    void set_server_ip(const char * server_ip)
    {
        c_sip.set_server_ip(server_ip);
    }

    void set_my_ip(const char * my_ip)
    {
        c_sip.set_my_ip(my_ip);
    }

    void set_credentials(const char * user, const char * password)
    {
        c_sip.set_credentials(user, password);
    }

    void set_event_handler(std::function<void(const SipClientEvent&)> handler)
    {
        c_sip.set_event_handler(handler);
    }
*/
    /**
     * Initiate a call async
     *
     * \param[in] local_number A number that is registered locally on the server, e.g. "**610"
     * \param[in] caller_display This string is displayed on the caller's phone
     */
/*
    void request_ring(const char * local_number, const char * caller_display)
    {
        c_sip.request_ring(local_number, caller_display);
    }

    void request_cancel()
    {
        c_sip.request_cancel();
    }
*/

*** File '(Unnamed)'
ST_
MD_
CT_
c_
p_
param_name
[100]
cl_state
cl_state
CSeq: 1 REGISTER

*** File '(Unnamed)'
Auth
nc
c_nc
qop
qop
qop
Contact:
To:
To:
Contact:
md5
compute_auth_response(

*** File '(Unnamed)'
sip_client.c
sip_client.c
sip_client.cqpop
sip_client.h
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c

*** File '* Startup Log *'
Processing '/etc/joe/joerc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/joerc

*** These modified files were found in JOE when it aborted on Wed Feb 28 13:33:44 2024
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
ST_
MD_
CT_
c_
p_
param_name
[100]
cl_state
cl_state
CSeq: 1 REGISTER

*** File '(Unnamed)'
uri
calculate
Calclate
Calculate
md5
compute_auth_response
uri
temp
send_sip_register
md5
method
compute

*** File '(Unnamed)'
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
config.h
sip_client.c

*** File '* Startup Log *'
Processing '/etc/joe/joerc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/joerc

*** These modified files were found in JOE when it aborted on Wed Feb 28 13:33:44 2024
*** JOE was aborted by UNIX signal 15

*** File '(Unnamed)'
MD_
CT_
c_
p_
param_name
[100]
cl_state
cl_state
CSeq: 1 REGISTER
case SS_

*** File '(Unnamed)'
ha2
ringing
rx
RINGING
state
SS_
RX MD_INVITE
p_media
MEDIA
p_body

*** File '(Unnamed)'
config.h
enums.h
sip_parse.h
sip_parse.c
config.h
sip_parse.h
sip_parse.c
sip_parse.c
sip_parse.c
sip_parse.h
sip_parse.c

*** File '* Startup Log *'
Processing '/etc/joe/joerc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/joerc

*** These modified files were found in JOE when it aborted on Wed Mar 13 02:25:04 2024
*** JOE was aborted because the terminal closed

*** File '(Unnamed)'
cl_state
cl_state
CSeq: 1 REGISTER
case SS_
MDDEBUG
;
case ST
:
ph_state
request_uri

*** File '(Unnamed)'
Contact:
sip_header
SS_INVITE_UNAUTH
SS_INVITE_UNAUTH_SENT
send_sip_ack
CALL_START
send_sip_ack
send_sip_invite
send_sip_ack
send_sip_invite
send_sip_ack
SS_INVITE_UNAUTH_SENT
send_sip_ack()

*** File '(Unnamed)'
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c
sip_client.c

*** File '* Startup Log *'
Processing '/etc/joe/joerc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/joerc

*** These modified files were found in JOE when it aborted on Wed May 15 23:51:05 2024
*** JOE was aborted because the terminal closed

*** File 'sip_client.c'
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

#include "pico/stdlib.h"
#include "pico/cyw43_arch.h"

#include "config.h"

#include "md5.h"
#include "sip_client.h"
#include "settings.h"

//from settings
extern const char *server_addr[]; // = DESTINATION_ADDR ;
extern int server_port[]; // = DESTINATION_PORT ;
extern const char *server_name[];
extern const char *sip_username[];
extern const char *sip_password[];
extern const char *sip_login[];

extern int sip_server_port;
extern int sip_local_port;
extern int rtp_local_port;

extern int server;

extern int registered;

extern int SendSound;
extern uint8_t enablertp;
// 
extern void send_sip_udp_blocking(char *,int,int);

extern char p_realm[];
extern char p_nonce[];
extern char p_media[];
extern char p_contact[];
extern char p_to_tag[];
extern char p_contant_type[];
extern char p_to[];
extern char p_from[];
extern char p_call_id[];
extern char p_cseq[];
extern char p_via[];
extern char p_qop[];
extern char p_opaque[];
extern char p_cip[];
extern char p_mport[];

extern enum Method p_method;
extern enum ContentType p_content_type;


extern int rdp_og_port;

int nc =0;

int strpos(const char *haystack, const char *needle, int offset){
   const char *p = strstr(haystack+offset, needle);
   if (p)
      return p - haystack+offset;
   return -1;
}

void substr(char *source, int a, int b, char *result) {
        strncpy(result, source+a, b);
}

void printMDState(enum Method state){
    STATETEXT
    printf("\nMethod:");
    switch (state) {
    case MD_NOTIFY:
        printf("MD_NOTIFY");
        break;
    case MD_BYE:
        printf("MD_BYE");
        break;
    case MD_INFO:
        printf("MD_INFO");
        break;
    case MD_INVITE:
        printf("MD_INVITE");
        break;
    case MD_UNKNOWN:
        printf("MD_UNKNOWN");
        break;
    case MD_CANCEL:
        printf("MD_CANCEL");
        break;
    case MD_OPTIONS:
        printf("MD_OPTIONS");
        break;    
    default:
        printf("METHOD NOT DEFINED"); 
    }    
    CLTEXT
    printf("\n");
}
        
void printState(enum SipState state){
    STATETEXT
    printf("\nSipState:");
    switch (state) {
      case SS_IDLE:
//        printf("IDLE");
        break;
      case SS_REGISTER_UNAUTH:
        printf("SS_REGISTER_UNAUTH");
        break;
      case SS_REGISTER_AUTH:
        printf("SS_REGISTER_AUTH");
        break;
      case SS_REGISTERED:
        printf("SS_REGISTERED");
        break;
      case SS_INVITE_UNAUTH:
        printf("SS_INVITE_UNAUTH");
        break;
      case SS_INVITE_UNAUTH_SENT:
        printf("SS_INVITE_UNAUTH_SENT");
        break;
      case SS_INVITE_AUTH:
        printf("SS_INVITE_AUTH");
        break;
      case SS_RINGING:
        printf("SS_RINGING");
        break;
      case SS_RINGTONE:
        printf("SS_RINGTONE");
        break;
      case SS_CALL_START:
        printf("SS_CALL_START");
        break;
      case SS_CALL_IN_PROGRESS:
        printf("SS_CALL_IN_PROGRESS");
        break;
      case SS_CANCELLED:
        printf("SS_CANCELLED");
        break;
      case SS_ERROR:
        printf("SS_ERROR");
        break;
      default:
        printf("SS NOT DEFINED");
    } 
    CLTEXT
    printf("\n");
}

void printRStatus(enum Status status){
    STATETEXT
    printf("\nStatus:");
    switch (status) {

      case ST_TRYING_100:
        printf("ST_TRYING_100");
        break;
      case ST_RINGING_180:
        printf("ST_RINGING_180");
        break;
      case ST_SESSION_PROGRESS_183:
        printf("ST_SESSION_PROGRESS_183");
        break;
      case ST_OK_200:
        printf("ST_OK_200");
        break;
      case ST_UNAUTHORIZED_401:
        printf("ST_UNAUTHORIZED_401");
        break;
      case ST_PROXY_AUTH_REQ_407:
        printf("ST_PROXY_AUTH_REQ_407");
        break;
      case ST_BUSY_HERE_486:
        printf("ST_BUSY_HERE_486");
        break;
      case ST_REQUEST_CANCELLED_487:
        printf("ST_REQUEST_CANCELLED_487");
        break;
      case ST_SERVER_ERROR_500:
        printf("ST_SERVER_ERROR_500");
        break;
      case ST_DECLINE_603:
        printf("ST_DECLINE_603");
        break;
      case ST_CANCEL_127:
        printf("ST_CANCEL_127");
        break;    
      case ST_UNKNOWN:
        printf("ST_UNKNOWN");
        break;
      default:
        printf("ST NOT DEFINED");    
    }
    CLTEXT
    printf("\n");

}

void printPhoneState(enum PhoneState status){
   STATETEXT
    printf("\nPhoneState:");
    switch (status) {
      case PS_IDLE:
        printf("PS_IDLE");
        break;
//      case PS_REGISTERED:
//        printf("PS_REGISTERED");
//        break;
      case PS_RINGING:
        printf("PS_RINGING");
        break;
      case PS_DIALLING:
        printf("PS_DIALLING");
        break;
      case PS_ANSWER:
        printf("PS_ANSWER");
        break;
      case PS_HANGUP:
        printf("PS_HANGUP");
        break;
      case PS_DECLINED:
        printf("PS_DECLINED");
        break;
      case PS_ESTABLISHED:
        printf("PS_ESTABLISHED");
        break;
      default:
        printf("NOT DEFINED");

    }
    CLTEXT
    printf("\n");

}

void sip_init(){
        printf("Sip Init\n");

        sprintf(c_server_ip,"%s",server_addr[server] );
        sprintf(c_uri, "sip:%s", c_server_ip);
        sprintf(c_login, "%s", sip_login[server]);
        sprintf(c_user, "%s", sip_username[server]);
        sprintf(c_pwd,"%s",sip_password[server]);

        sprintf(c_to_uri, "%s@%s",c_user,c_server_ip);
        sprintf(c_my_ip,"%s",ip4addr_ntoa(netif_ip4_addr(netif_list)) );
//        sprintf(c_caller_display,"%s",INIT_DISPLAY);

        sprintf(c_call_id,"%i",rand() % 2147483647);
        sprintf(c_tag,"%i",rand() % 2147483647);
        sprintf(c_cnonce,"%i",rand() % 2147483647);

        nc++;

        sprintf(c_nc,"%08i",nc);        

        char buffer[500];        

        sprintf(buffer,"\nSIP INIT\n");
        sprintf(buffer,"%sServer:IP %s\n",buffer,c_server_ip);
        sprintf(buffer,"%sLogin:%s\n",buffer,c_login);
        sprintf(buffer,"%sUser:%s\n",buffer,c_user);
        sprintf(buffer,"%sRealm:%s\n",buffer,c_realm);

        sprintf(buffer,"%s\n\n",buffer);
        printf("%s",buffer);

        sprintf(buffer,"%sPass:%s\n",buffer,c_pwd);
        log_file_save("## Sip Setings:\n",buffer);                
}


void request_ring(const char* call_no, const char* caller_display){
    if (registered){         
        printf("Request to call %s...\n", call_no);
//        c_call_id = rand() % 2147483647;
        sprintf(c_call_id,"%i",rand() % 2147483647);
        sprintf(c_call,"%s",call_no);          
        ph_state=PS_DIALLING;
        cl_state = SS_INVITE_UNAUTH;
        tx();

        }else{
             printf("Not registered\n");
        }  
    }

    //request cancel from THIS phone.
    void request_cancel()
    {
        if ((cl_state == SS_RINGING)){
            printf( "Request to BUSY when RINGING call\n");
            send_sip_busy();
        }        
        if ((cl_state == SS_CALL_IN_PROGRESS)) {
            printf( "Request to CANCEL ESTABLISHED call\n");
            send_sip_bye();
        }
        ph_state = PS_IDLE;
        cl_state = SS_IDLE;
        enablertp=0;
        tx();
    }

    //send responce on cl_state
    void tx(){
        TXTEXT
        char temp[50];
        int ssrc;
        switch (cl_state) {
        case SS_IDLE:
            //fall-through
            break;
        case SS_REGISTER_UNAUTH:
            //sending REGISTER without auth
            printf("TX SS_REGISTER_UNAUTH\n");
            printf(c_tag,"%i",rand() % 2147483647);
            c_branch = rand() % 2147483647;
            send_sip_register();
            sprintf(c_tag,"%i",rand() % 2147483647);
            c_branch = rand() % 2147483647;
            break;
        case SS_REGISTER_AUTH:
            printf("TX SS_REGISTER_AUTH\n");
            //sending REGISTER with auth
            //must be the same as uri in Response
            sprintf(temp,"sip:%s:%i", c_my_ip,sip_local_port);
            compute_auth_response("REGISTER", temp);
            send_sip_register();
            break;
        case SS_REGISTERED:
            printf("TX SS_REGISTERED\n");
//            ph_state=PS_REGISTERED;
             registered=1;
            //options
            if(p_method==MD_OPTIONS){
                send_sip_options();// should be 200
            }
            cl_state = SS_IDLE;
            break;
        case SS_INVITE_UNAUTH:
            printf("TX SS_INVITE_UNAUTH\n");
            //sending INVITE without auth
            //c_tag = rand() % 2147483647;
            sprintf(c_nonce,"");
            sprintf(c_realm,"");
            sprintf(c_response,"");

            c_response[0]=0; // ensure no pre vious responce is used
            sprintf(c_response,"");
            c_sdp_session_id = rand();
            send_sip_invite();
            break;
        case SS_INVITE_UNAUTH_SENT:
            printf("TX SS_INVITE_UNAUTH_SENT\n");
            break;
        case SS_INVITE_AUTH:
            printf("TX SS_INVITE_AUTH\n");
            //sending INVITE with auth
            c_branch = rand() % 2147483647;
            char uri[100];
            sprintf(uri,"sip:%s@%s",c_call,c_server_ip); 
            compute_auth_response("INVITE", uri);
            send_sip_invite();
            break;
        case SS_RINGING:
            printf("TX SS_RINGING\n");
            // RTP ssrc generation
            ssrc = rand() % 2147483647;
            if (p_method==MD_CANCEL){
                send_sip_ok(0);
//                sleep_ms(100);
                send_request_terminated();
//                ph_state=PS_REGISTERED;
                cl_state=SS_IDLE;              
            }
            if (ph_state==PS_DECLINED){
                printf("Sending cancel from DECLINE request\n");
                send_sip_cancel();
                ph_state=PS_IDLE;
                cl_state=SS_IDLE;
                enablertp=0;
            }
            break;
        case SS_CALL_START:
            printf("TX CALL_START\n");
            send_sip_ack();
            break;
        case SS_CALL_IN_PROGRESS:
            printf("TX SS_CALL_IN_PROGRESS\n");
//            if (ph_state==PS_ESTABLISHED){
//                printf( "Sending bye from ESTABLISHED request");
//                send_sip_bye();
//                ph_state=PS_IDLE;
//                cl_state=SS_IDLE;
//            }
            break;
        case SS_CANCELLED:
            printf("TX SS_CANCELED\n");
            send_sip_ack();
            printf(c_tag,"%i",rand() % 2147483647);
            c_branch = rand() % 2147483647;
            break;
        case SS_ERROR:
            printf("TX SS_ERROR %i\n",cl_state);
            break;
        }
        CLTEXT
    }

    void rx()
    {
        RXTEXT
    
        printf ("\n\nRX ");
        printState(cl_state);
        printf(" ");
        printRStatus(p_status);

        if (cl_state == SS_REGISTERED) {
           printf("RX REGISTERED\n");
   //             cl_state = SS_INVITE_UNAUTH;
        } else if (cl_state == SS_ERROR) {
            printf("RX SS_ERROR\n");
//            sleep_ms(100);
            c_sip_sequence_number++;
            cl_state = SS_IDLE;
            return;
        } else if (cl_state == SS_INVITE_UNAUTH) {
            printf("RX INVITE_UNAUTH\n");
            cl_state = SS_INVITE_UNAUTH_SENT;
        } else if (cl_state == SS_CALL_START) {
            printf("RX CALL_START\n");
//            cl_state = SS_CALL_IN_PROGRESS;
            return;
        } 
        
        // Parce received packet
        if (!parse()) {
            printf("!!!!!!!!!!!!!!!!! Parsing the packet failed !!!!!!!!!!!!!!!!!!!!!!!!!!!");
            return;
        }
        
        printf("After Parse\n");        
        printRStatus(p_status);
        printMDState(p_method);
        printPhoneState(ph_state);
        
        
        enum Status reply = p_status;   //replay= parced status
        printf( "Parsing the packet ok, reply code=%d\n", p_status); 

        if (reply == ST_SERVER_ERROR_500) {
            printf("RX SERVER_ERROR_500\n");
            //log_state_transition(cl_state, SS_ERROR);
            cl_state = SS_ERROR;
            return;
        } else if ((reply == ST_UNAUTHORIZED_401) || (reply == ST_PROXY_AUTH_REQ_407)) {
            printf("RX UNAUTHORIZED_401 PROXY_AUTH_REQ_407\n");
            sprintf(c_realm,"%s",p_realm );
            strncat(c_nonce,p_nonce,PARSE_MAX);
        } else if ((reply == ST_RINGING_180)){
            cl_state=SS_RINGTONE;
            printf("RX RINGTONE\n");    
        } else if ((reply == ST_UNKNOWN) && ((p_method == MD_NOTIFY) || (p_method == MD_BYE) || (p_method == MD_INFO) || (p_method == MD_INVITE))) {
            printf("RX MD_Various :)\n");
             //ok to immediatly answer, or ringing...    
//            send_sip_ok();
            
            if ((p_method == MD_INVITE)) {
                printf("RX MD_INVITE :)\n");
                printf("p_media: %s\n",p_media);
                int m1=strpos(p_media," ",0); 
            
                int m2=strpos(p_media," ",m1+1);
                printf("%i %i\n",m1,m2);
                substr(p_media,m1 + 1, m2 - m1 - 1,rtp_port);                
                printf("%s",rtp_port);

                sprintf(rtp_ip,"%s",p_cip);                    
                //RTP TO DO
                
                printf("RTP IP %s\n",p_cip);
                sprintf(c_call_id,"%s",p_call_id);
                //get port from invite
                rdp_og_port=atoi(p_mport);
                
                send_sip_ringing();
                cl_state=SS_RINGING;
            }
            
            if ((p_method == MD_BYE)) {
                printf("RX BYE\n");
                send_sip_ok(0);
                cl_state=SS_IDLE;
                ph_state=PS_IDLE;
                enablertp=0;
            
            }
            
             if ((p_method == MD_CANCEL)) {
                printf("RX CANCEL\n");
                 send_sip_ok(0);
                cl_state=SS_IDLE;
                ph_state=PS_IDLE;
                enablertp=0;
             }   
            
        }
/*
        if(reply == ST_OK_200 && ph_state == PS_DIALLING){
           cl_state = SS_INVITE_AUTH;
           tx();
        }
*/
       
        

        if (p_contact[0]) {
            sprintf(c_to_contact,"%",p_contact);
        }

        if (p_to_tag[0]) {
            sprintf(c_to_tag,"%s",p_to_tag);
        }

        enum SipState old_state = cl_state;
//        printf ("Start of RX switch\n");
        printState(cl_state);        
        switch (cl_state) {
        case SS_IDLE:
            break;
        case SS_REGISTER_UNAUTH:
            printf("RX SS_REGISTER_UNAUTH \n");
            cl_state = SS_REGISTER_AUTH;
            c_sip_sequence_number++;
            break;
        case SS_REGISTER_AUTH:
            printf("RX SS_REGISTER_AUTH \n");
            if (reply == ST_OK_200) {
                printf("RX ST_OK_200 )\n");
                c_sip_sequence_number++;
                sprintf(c_nonce,"");
                sprintf(c_realm,"");
                sprintf(c_response,"");
                printf( "REGISTER - OK :)");
                
                cl_state = SS_REGISTERED;
//                ph_state = PS_REGISTERED;
                registered=1;
            } else {
                cl_state = SS_ERROR;
                printf("RX SS_ERROR \n");
            }
            break;
        case SS_REGISTERED:
            printf("RX SS_REGISTERED \n");
//            if (p_method == MD_INVITE  ) {            
            //answer incoming call here ?
//              if(ph_state==PS_ANSWER){             
                //received an invite, answered it already with ok, so new call is established, because someone called us
//                cl_state = SS_CALL_START;
//                printf ("State changed to CALL_START\n");
//                printf("Send OK to answer \n");
//                send_sip_ok();
//                ph_state==PS_ESTABLISHED;
//              }  
//              if(ph_state==PS_DIALLING){
//                  
//              }
//            }
            break;
        case SS_INVITE_UNAUTH_SENT:
            printf("RX SS_INVITE_UNAUTH SENT\n");
//            c_sip_sequence_number++;
            send_sip_ack();
        case SS_INVITE_UNAUTH:
            printf("RX SS_INVITE_UNAUTH - reply %i\n",reply);
            if ((reply == ST_UNAUTHORIZED_401) || (reply == ST_PROXY_AUTH_REQ_407)) {
                printf("RX ST_UNAUTHORIZED_401 / ST_PROXY_AUTH_REQ_407 \n");
                cl_state = SS_INVITE_AUTH;
                c_sip_sequence_number++;
            } else if ((reply == ST_OK_200) || (reply == ST_SESSION_PROGRESS_183)) {
                printf("ST_OK_200 / ST_SESSION_PROGRESS_183\n");
                cl_state = SS_RINGING;
                sprintf(c_nonce,"");
                sprintf(c_realm,"");
                sprintf(c_response,"");
                printf( "Start RINGing...");
            } else if (reply != ST_TRYING_100) {
                cl_state = SS_ERROR;
            }
            break;
        case SS_INVITE_AUTH:
            printf("RX SS_INVITE_AUTH - reply %i\n",reply);
            if ((reply == ST_UNAUTHORIZED_401) || (reply == ST_PROXY_AUTH_REQ_407)) {
                printf("ST_UNAUTHORIZED_401 / ST_PROXY_AUTH_REQ_407\n");
                cl_state = SS_ERROR;
            } else if ((reply == ST_OK_200) || (reply == ST_SESSION_PROGRESS_183) || (reply == ST_TRYING_100)) {
                printf("ST_OK_200 / ST_SESSION_PROGRESS_183 / reply == ST_TRYING_100\n");
                //trying is not yet ringing, but change state to not send invite again
                cl_state = SS_RINGING;
                sprintf(c_nonce,"");
                sprintf(c_realm,"");
                sprintf(c_response,"");
                printf( "Start RINGing...");
            } else {
                cl_state = SS_ERROR;
            }
            break;
        case SS_RINGTONE:
            if (reply == ST_OK_200) {
                printf("RINGTONE ST_OK_200\n");
                //other side picked up, send an ack
                send_sip_ack();
                cl_state = SS_CALL_IN_PROGRESS;
                ph_state = PS_ESTABLISHED;
                
                printf("###RDP 1 ### set RDP %s:%s\n",p_cip,p_mport);
                rdp_og_port=atoi(p_mport);
                enablertp=1;
                
            }   
            break; 
        case SS_RINGING:
            printf("SS_RINGING\n");
            if (reply == ST_SESSION_PROGRESS_183) {
                printf("ST_SESSION_PROGRESS_183\n");
                //TODO parse session progress reply and send appropriate answer
                //cl_state = SS_ERROR;
            } else if (reply == ST_OK_200) {
                printf("ST_OK_200\n");
                
                //I think this is wrong, you answer, you dont receive a 200 !
                
                 printf("###RDP 2 ### set RDP %s:%s\n",p_cip,p_mport);                 
                 enablertp=1;    
                 
                 rdp_og_port=atoi(p_mport);
                 
                              
                cl_state = SS_CALL_START;
                ph_state=PS_ESTABLISHED;
            } else if (reply == ST_REQUEST_CANCELLED_487) {
                cl_state = SS_CANCELLED;
                 printf("SS_CANCELLED\n");
                 cl_state = SS_IDLE;
            } else if (reply == ST_PROXY_AUTH_REQ_407) {
                printf("ST_PROXY_AUTH_REQ_407\n");
                send_sip_ack();
                c_sip_sequence_number++;
                cl_state = SS_INVITE_AUTH;
                printf( "Go back to send invite with auth...");
            } else if ((reply == ST_DECLINE_603) || (reply == ST_BUSY_HERE_486)) {
                printf("ST_DECLINE_603 ST_BUSY_HERE_486\n");
                send_sip_ack();
                c_sip_sequence_number++;
                c_branch = rand() % 2147483647;
                cl_state = SS_IDLE;
                enum CancelReason cancel_reason = CR_CALL_DECLINED;
                if (reply == ST_BUSY_HERE_486) {
                    cancel_reason = CR_TARGET_BUSY;
                }
                // might need to send an actual cancel here
                cl_state = SS_IDLE;
            }
            break;
        case SS_CALL_START:
            //should not reach this point
            printf("Call START-ERROR\n");
            break;
        case SS_CALL_IN_PROGRESS:
            printf("SS_CALL_IN_PROGRESS\n");
            if (p_method == MD_BYE) {
                c_sip_sequence_number++;
                send_sip_ack();
                cl_state = SS_IDLE;
                ph_state = PS_IDLE;
                enablertp=0;
//                ss_state = 
            } else if ((p_method == MD_INFO) && (p_content_type == CT_APPLICATION_DTMF_RELAY)) {
                printf("MD_INFO / CT_APPLICATION_DTMF_RELAY\n");
            }
            break;
        case SS_CANCELLED:
            printf("SS_CANCELLED\n");
            if (reply == ST_OK_200) {
                c_sip_sequence_number++;
                send_sip_ack();
                cl_state = SS_IDLE;
            }
            break;
        case SS_ERROR:
            printf("SS_ERROR\n");
            c_sip_sequence_number++;
            cl_state = SS_IDLE;
            break;
        }

        if (old_state != cl_state) {
            //log_state_transition(old_state, cl_state);
        }
        CLTEXT
    }

    void  answer_ringing(){
       printf("Answer Ringing\n");
       
       send_sip_ok(1);
       enablertp=1;
       cl_state=SS_CALL_IN_PROGRESS;
       ph_state=PS_ESTABLISHED;
    }

    void send_sip_register()
    {
        TXTEXT
        printf("Send SIP Register\n");
        char buffer[2048];
        
        char request_uri[100];
        sprintf(request_uri,"sip:%s:%i", c_my_ip,sip_local_port);
        
        char to_uri[100];
        sprintf(to_uri,"%s@%s",c_login,c_my_ip);
        
        char from_uri[100];
        sprintf(from_uri,"%s@%s",c_login,c_my_ip);              

        sip_header("REGISTER", request_uri, from_uri, to_uri, c_tag, c_to_tag, buffer);
        sprintf(buffer,"%sContact: <sip:%s@%s:%i;%s>\r\n",buffer,c_login,c_my_ip,sip_local_port,TRANSPORT_LOWER  );

        if (c_response[0]) {
            sprintf(buffer,"%sAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", algorithm=MD5, response=\"%s\", qop=%s, opaque=\"%s\", cnonce=\"%s\", nc=%s\r\n",
               buffer, c_user ,c_realm ,c_nonce, request_uri ,c_response,p_qop,p_opaque,c_cnonce,c_nc );            
        }
        sprintf(buffer,"%sAllow: INVITE, ACK, CANCEL, BYE, REFER, NOTIFY, MESSAGE, SUBSCRIBE, INFO, REGISTER\r\n",buffer);
        sprintf(buffer,"%sExpires: 600\r\n",buffer);
        sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
        sprintf(buffer,"%s\r\n",buffer);

        //printf("\n\nSIP Register - Send UDP \n%s\nLEN %i\n",buffer,strlen(buffer));
        printf("SIP Register \n");
        send_sip_udp_blocking(buffer,strlen(buffer)-1,0);
    }
    
    void send_sip_busy(){
        printf("Send SIP Busy\n");
        char buffer[2048];
        sprintf(buffer,"");
        sip_reply_header("486 Busy Here"  ,  buffer);
        sprintf(buffer,"%sAllow: INVITE, OPTIONS, INFO, BYE, CANCEL, ACK, UPDATE, REFER, SUBSCRIBE, NOTIFY\n\r",buffer);
        sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
        sprintf(buffer,"%s\r\n",buffer);
        send_sip_udp_blocking(buffer,strlen(buffer)-1,0);
    
    }
    
    void send_sip_options(){
        TXTEXT
        printf("Send SIP Options\n");
        char buffer[2048];
        sprintf(buffer,"");
        sip_reply_header("200 OK"  ,  buffer);
        sprintf(buffer,"%sAllow: INVITE, OPTIONS, INFO, BYE, CANCEL, ACK, UPDATE, REFER, SUBSCRIBE, NOTIFY\n\r",buffer);
        sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
        sprintf(buffer,"%s\r\n",buffer);

        //printf("%s\n",buffer);
        printf("SIP Options \n");
        send_sip_udp_blocking(buffer,strlen(buffer)-1,0);
    }

    void populate_sdp(char * sdp_buffer){
    
        sprintf(sdp_buffer,"v=0\r\no=- 0 4 IN IP4 %s\r\n",c_my_ip);
        sprintf(sdp_buffer,"%ss=SDP data\r\nt=0 0\r\n",sdp_buffer);
//        sprintf(sdp_buffer,"%sm=audio %i RTP/AVP 0 8 101\r\n",sdp_buffer,rtp_local_port);
        sprintf(sdp_buffer,"%sm=audio %i RTP/AVP 0 101\r\n",sdp_buffer,rtp_local_port);
        sprintf(sdp_buffer,"%sc=IN IP4 %s\r\n",sdp_buffer,c_my_ip);        
        sprintf(sdp_buffer,"%sa=rtcp:%i IN IP4 %s\r\n",sdp_buffer,rtp_local_port+1,c_my_ip);
        sprintf(sdp_buffer,"%sa=sendrecv\r\n",sdp_buffer);
        sprintf(sdp_buffer,"%sa=rtpmap:0 PCMU/8000\r\n",sdp_buffer);
//        sprintf(sdp_buffer,"%sa=rtpmap:8 PCMA/8000\r\n",sdp_buffer);
        sprintf(sdp_buffer,"%sa=rtpmap:101 telephone-event/8000\r\n",sdp_buffer);
        sprintf(sdp_buffer,"%sa=ptime:20\r\n",sdp_buffer);
        sprintf(sdp_buffer,"%sa=fmtp:101 0-15\r\n",sdp_buffer);
    }

    void send_sip_invite()
    {
        TXTEXT
        printf("Send SIP Invite\n");
        char buffer[2048];
        char sdp_buffer[1024];
        char from_uri[100];
        char to_uri[100];

        sprintf(to_uri,"%s@%s",c_call,c_server_ip);         
        sprintf(from_uri,"%s@%s",c_login,c_server_ip); 
        
        char request_uri[100];
        sprintf(request_uri,"sip:%s",to_uri);
        
        sip_header("INVITE", request_uri, from_uri ,to_uri , c_tag, "", buffer);
        sprintf(buffer,"%sContact: \"%s\" <sip:%s@%s:%i>\r\n",buffer,c_user,c_login,c_my_ip,sip_local_port );
        
        if (c_response[0]) {
              sprintf(buffer,"%sAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"sip:%s\", algorithm=MD5, response=\"%s\", qop=%s, opaque=\"%s\", cnonce=\"%s\", nc=%s\r\n"
                  ,buffer, c_user ,c_realm ,c_nonce,to_uri ,c_response,p_qop,p_opaque,c_cnonce,c_nc );
        }
        sprintf(buffer,"%sContent-Type: application/sdp\r\n",buffer);
        sprintf(buffer,"%sAllow: INVITE, ACK, CANCEL, BYE, REFER, NOTIFY, MESSAGE, SUBSCRIBE, INFO, REGISTER\r\n",buffer);
        
        populate_sdp(sdp_buffer);

        sprintf(buffer,"%sContent-Length: %i\r\n",buffer,strlen(sdp_buffer));
        sprintf(buffer,"%s\r\n%s",buffer,sdp_buffer);
        printf("SIP Invite\n");
        
        send_sip_udp_blocking(buffer,strlen(buffer)-1,0);
    }
    
    

    /**
     * CANCEL a pending INVITE
     *
     * To match the INVITE, the following parameter must not be changed:
     * * CSeq
     * * From tag value
     */
    void send_sip_cancel()
    {
        TXTEXT
        printf("Send Sip Cancel\n");
        char buffer[2048];
        char from_uri[100];
        sprintf(from_uri,"%s@%s",c_login,c_my_ip);
        
        sip_header("CANCEL", c_uri, from_uri, c_to_uri, c_tag, c_to_tag, buffer);
        if (c_response[0]) {
            sprintf(buffer,"%sContact: \"%s\" <sip:%s@%s:%i;transport=%s>\r\n",buffer,c_user,c_user ,c_my_ip,sip_local_port,TRANSPORT_LOWER );
            sprintf(buffer,"%sContent-Type: application/sdp\r\n",buffer);
            sprintf(buffer,"%sAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s,\"\r\n",buffer,c_user,c_realm ,c_nonce,c_uri,c_response );
        }
        sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
        sprintf(buffer,"%s\r\n",buffer);

        printf("%s\n",buffer);
        printf("SIP Cancel\n");
        send_sip_udp_blocking(buffer,strlen(buffer)-1,0);
    }

    /**
     * BYE a pending CALL
     * ~ todo sikor
     * To match the CALL, the following parameter must not be changed:
     * * CSeq
     * * From tag value
     */
    void send_sip_bye()
    {
        TXTEXT
        char buffer[2048];
        c_sip_sequence_number = 104;

        char from_uri[100];
        sprintf(from_uri,"%s@%s",c_login,c_my_ip);

        sip_header("BYE", c_uri, from_uri, c_to_uri, c_tag, c_to_tag, buffer);

        if (c_response[0]) {
            sprintf(buffer,"%sContact: \"%s\" <sip:%s@%s:%i;transport=%s>\r\n",buffer,c_user,c_user ,c_my_ip,sip_local_port,TRANSPORT_LOWER );
            sprintf(buffer,"%sContent-Type: application/sdp\r\n",buffer);
            sprintf(buffer,"%sMax-Forwards: 70\r\n",buffer);
            sprintf(buffer,"%sAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s,\"\r\n",buffer,c_user,c_realm ,c_nonce,c_uri,c_response );
        }
        sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
        sprintf(buffer,"%s\r\n",buffer);
        //printf("%s\n",buffer);
        printf("SIP Bye \n");
        send_sip_udp_blocking(buffer,strlen(buffer)-1,0);
    }

    void send_sip_ack()
    {
       TXTEXT
        char buffer[2048];      
        char sdp_buffer[1024];
        
        char to_uri[100];
        char from_uri[100];
        char request[100];
                
        if (cl_state == SS_CALL_START) {
            printf("ACK Call Start\n");
            sprintf(to_uri,"sip:%s@%s",c_user,c_server_ip);
            sprintf(from_uri,"sip:%s@%s",c_login,c_my_ip);

            sip_header("ACK", c_to_contact, from_uri, c_to_uri,c_tag, c_to_tag, buffer);          
            sprintf(sdp_buffer,"v=0\r\n");
            sprintf(sdp_buffer,"t=0 0\r\n");
            sprintf(buffer,"%sContent-Type: application/sdp\r\n",buffer);
//            sprintf(buffer,"%sAllow-Events: telephone-event\r\n",buffer);
            sprintf(buffer,"%sContent-Length: %s\r\n",buffer,strlen(sdp_buffer));
            sprintf(buffer,"%s\r\n%s",buffer,sdp_buffer);
        } else {
            printf("ACK NOT Call Start\n");
            sprintf(to_uri,"%s@%s",c_call,c_server_ip);
            sprintf(from_uri,"%s@%s",c_login,c_server_ip);
            sprintf(request,"sip:%s@%s:%i",c_call,c_server_ip,sip_local_port);
            sip_header("ACK", request, from_uri,to_uri,c_tag, c_to_tag, buffer);
            sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
            sprintf(buffer,"%s\r\n",buffer);
        }
        //printf("%s\n",buffer);
        printf("SIP ACK\n");
        send_sip_udp_blocking(buffer,strlen(buffer)-1,0);
    }

    void send_sip_ok(int withsdp){
        TXTEXT
//        printf("Send Sip OK\n");
        char buffer[2048];
        char sdp_buffer[1024];
        sprintf(buffer,"");
        sip_reply_header("200 OK"  ,  buffer);
//        sprintf(buffer,"%sUser-Agent: %s\r\n",buffer,USER_AGENT);
        sprintf(buffer,"%sContact: <sip:%s@%s:%i>\r\n",buffer,c_login,c_my_ip,sip_local_port);
        sprintf(buffer,"%sAllow: INVITE, OPTIONS, INFO, BYE, CANCEL, ACK, UPDATE, REGISTER, SUBSCRIBE, NOTIFY\r\n",buffer);
        if(withsdp){
            printf("  With SDP\n");
            populate_sdp(sdp_buffer);
            sprintf(buffer,"%sContent-Type: application/sdp\r\n",buffer);
            sprintf(buffer,"%sContent-Length: %i\r\n",buffer,strlen(sdp_buffer));           
            sprintf(buffer,"%s\r\n%s",buffer,sdp_buffer);
        }else{
            sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
        }
        sprintf(buffer,"%s\r\n",buffer);
        //printf("%s\n",buffer);
//        printf("SIP OK\n");
        send_sip_udp_blocking(buffer,strlen(buffer)-1,0);
        
    }

    void send_request_terminated(){
        TXTEXT
        printf("Send SipRequest Terminatedu\n");
        char buffer[2048];
        sprintf(buffer,"");
        sip_reply_header("487 Request Terminated"  ,  buffer);
        sprintf(buffer,"%sUser-Agent: %s\r\n",buffer,USER_AGENT);
        sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
        sprintf(buffer,"%s\r\n",buffer);
        
        //printf("%s\n",buffer);
        printf("SIP Request Terminated\n");
        send_sip_udp_blocking(buffer,strlen(buffer)-1,0);
        
    }

    void send_sip_ringing()
    {
        TXTEXT
        printf("Send Sip Ringing\n");
        //add tag to TO
        int tag=rand() % 2147483647;
        sprintf(p_to,"%s;tag=%i",p_to,tag);

        char buffer[2048];
        sip_reply_header("180 Ringing"  ,  buffer);
        sprintf(buffer,"%sContact: \"%s\" <sip:%s@%s:%i>\r\n",buffer,c_user,c_login ,c_my_ip,sip_local_port);
        sprintf(buffer,"%sAllow: INVITE, ACK, BYE, OPTIONS, NOTIFY, REGISTER, CANCEL\r\n",buffer);
        sprintf(buffer,"%sContent-Length: 0\r\n",buffer);
        sprintf(buffer,"%s\r\n",buffer);
                
//        printf("SIP Ringing\n");
        send_sip_udp_blocking(buffer,strlen(buffer)-1,0);
        
    }

    void sip_header(const char * command, const char * request_uri, char * from_uri, char * to_uri, char * from_tag, char * to_tag, char * buffer)
    {
        TXTEXT
        printf("sip_header CMD:%s\n",command);
        sprintf(buffer,"%s %s SIP/2.0\r\n",command,request_uri);  

        sprintf(buffer,"%sCSeq: %i %s \r\n",buffer,c_sip_sequence_number,command );
        sprintf(buffer,"%sCall-ID: %s\r\n",buffer,c_call_id);
        sprintf(buffer,"%sMax-Forwards: 70\r\n",buffer);
        sprintf(buffer,"%sUser-Agent: %s\r\n",buffer,USER_AGENT);
        
        
        if (strcmp(command,"INVITE")==0) {
            printf("Header INVITE");
             if(from_tag[0]){
                sprintf(buffer,"%sFrom: \"%s\" <sip:%s>;tag=%s\r\n",buffer,c_user,from_uri,from_tag);
             }else{
                sprintf(buffer,"%sFrom: \"%s\" <sip:%s>\r\n",buffer,c_user,from_uri);
             }   
        } else if (strcmp(command,"REGISTER")==0) {
            printf("Header REGISTER\n");
              if(from_tag[0]){
                  sprintf(buffer,"%sFrom: <sip:%s>;tag=%s\r\n",buffer,from_uri,from_tag);
              }else{
                  sprintf(buffer,"%sFrom: <sip:%s>\r\n",buffer,from_uri);
              }    
        } else {
            printf("Header not REGISTER or INVITE\n");
            if(from_tag){
                sprintf(buffer,"%sFrom: <sip:%s>;tag=%s\r\n",buffer,from_uri,from_tag);
            }else{
                sprintf(buffer,"%sFrom: <sip:%s>\r\n",buffer,from_uri);
            }
            
        }
        sprintf(buffer,"%sVia: SIP/2.0/%s %s:%i;branch=z9hG4bK-%i\r\n",buffer,TRANSPORT_UPPER,c_my_ip ,sip_local_port,c_branch);

        if ((strcmp(command,"ACK")!=0) && (c_to_tag[0])) {
            printf("notACK\n");
            if(to_tag[0]>0){ 
                sprintf(buffer,"%sTo: <sip:%s>;tag=%s\r\n",buffer,to_uri,to_tag);   
            }else{
                sprintf(buffer,"%sTo: <sip:%s>\r\n",buffer,to_uri);
            }
        } else {
            printf("ACK\n");
            if(to_tag>0){
                sprintf(buffer,"%sTo: <sip:%s>;tag=%s\r\n",buffer,to_uri,to_tag);
            }else{
                sprintf(buffer,"%sTo: <sip:%s>\r\n",buffer,to_uri);
            }
        }
    }


    void sip_reply_header(char * code,char * buffer)
    {
        TXTEXT
        printf("Sip Reply header %s\r\n",code);
        sprintf(buffer,"SIP/2.0 %s\r\n",code);
        sprintf(buffer,"%sTo: %s\r\n",buffer,p_to);
        sprintf(buffer,"%sFrom: %s\r\n",buffer,p_from);
        sprintf(buffer,"%sVia: %s\r\n",buffer,p_via);
        sprintf(buffer,"%sCSeq: %s\r\n",buffer,p_cseq);
        sprintf(buffer,"%sCall-ID: %s\r\n",buffer,p_call_id);
        sprintf(buffer,"%sMax-Forwards: 70\r\n",buffer);      
        sprintf(buffer,"%sUser-Agent: %s\r\n",buffer,USER_AGENT);        
        printf("Sip Reply Header End\n");
        
    }
    

    bool read_param_client(const char * line, const char * parac_name, char * output)
    {
        char param[100];
        sprintf(param,"%s=\"",parac_name);
        int pos = strpos(line,param,0);
        if (pos == -1) {
            return false;
        }
        pos += strlen(param);
        int pos_end = strpos(line,param,pos);
        if (pos_end == -1) {
            return false;
        }
        substr(line,pos,pos_end,output);
        return true;
    }

    void compute_auth_response(const char * method, const char * request_uri)
    {
        char ha1_text[50]; //32char long hex of 16 chars
        char ha2_text[50];
        char ccnonce[100];
        sprintf(c_response,"");
        char data[1024];
        MD5_CTX mdContext;
        
        //HA1 from user realm password
        sprintf(data,"%s:%s:%s",c_user,c_realm,c_pwd);
        
        MD5Init (&mdContext);
        MD5Update (&mdContext,data,strlen(data));
        MD5Final (&mdContext);

        to_hex(ha1_text, mdContext.digest, 16);
        
#ifdef MDDEBUG        
        printf("\n                      user:realm:pwd\n");
        printf("Calculating md5 for : %s\n", data);
        printf("Hex ha1 is %s\n", ha1_text);
#endif
        //HA2 Method request_uri
        //data = method + ":" + request_uri;
        sprintf(data,"%s:%s",method,request_uri);
        
        MD5Init (&mdContext);
        MD5Update (&mdContext,data,strlen(data));
        MD5Final (&mdContext);

        to_hex(ha2_text, mdContext.digest, 16);
        
#ifdef MDDEBUG
        printf( "\n                    method:request_uri\n");
        printf( "Calculating md5 for : %s\n", data);
        printf( "Hex ha2 is %s\n", ha2_text);
#endif

        if(p_qop[0]==0){
           //without QOP
           //responce HA1 nonce HA2         
#ifdef MDDEBUG           
           printf("\n                ha1:nonce:ha2\n");
#endif
           sprintf(data,"%s:%s:%s",ha1_text,c_nonce, ha2_text);
        }else{
           //with QOP
           //responce HA1 nonce cnonce qop HA2

#ifdef MDDEBUG
           printf("\nQOP AUTH\n");
           printf("\n                ha1:nonce:nc,cnonce:qop:ha2\n");
#endif

           sprintf(data,"%s:%s:%s:%s:%s:%s",ha1_text,c_nonce,c_nc,c_cnonce,p_qop,ha2_text);

        } 

        MD5Init (&mdContext);
        MD5Update (&mdContext,data,strlen(data));
        MD5Final (&mdContext);

        to_hex(c_response,  mdContext.digest, 16);
        
#ifdef MDDEBUG
        printf("\nCalculating md5 for : %s\n", data);
        printf("Hex response is %s\n", c_response);
#endif

    }

    void to_hex(char * dest, const unsigned char* data, int len)
    {
        static const char hexits[17] = "0123456789abcdef";
        int c=0;
        for (int i = 0; i < len; i++) {
            dest[c]=hexits[data[i] >> 4];
            c++;
            dest[c]=hexits[data[i] & 0x0F];
            c++;
        }
        dest[c]=0;
    }

*** File '(Unnamed)'
g711
RTPPacket_
RTPPacket
RTP
s_buffer
r_buffer
s_buffer
s_buffer
s_buffer
SDP data

*** File '(Unnamed)'
rport
rport
Via
p_via
instr
Via
VIA
Allow
sipcall
r
trying
RINGING
TRYING

*** File '(Unnamed)'
sip_client.c
sip_parse.c
sip_parse.h
sip_parse.c
sip_parse.c
sip_parse.c
sip_parse.c
sip_parse.c
sip_client.c
sip_client.c
sip_client.c

*** File '* Startup Log *'
Processing '/etc/joe/joerc'...
Processing '/etc/joe/ftyperc'...
Finished processing /etc/joe/ftyperc
Finished processing /etc/joe/joerc
